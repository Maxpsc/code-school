# 动态规划总结与练习

## 🎉 恭喜你完成学习！

通过滑雪问题和背包问题的学习，你已经掌握了动态规划的核心思想和常见技巧。

## 📝 核心知识点回顾

### 1. 动态规划的本质

> **将大问题分解为小问题，记住子问题的答案，避免重复计算**

**两个关键特征**：
- ✅ 最优子结构：大问题的最优解包含小问题的最优解
- ✅ 重叠子问题：会反复遇到相同的子问题

### 2. 解题四步骤

```
1️⃣ 定义状态：dp[i] 或 dp[i][j] 代表什么？
2️⃣ 找状态转移方程：如何从小问题推导大问题？
3️⃣ 确定边界条件：初始状态是什么？
4️⃣ 确定计算顺序：自顶向下还是自底向上？
```

### 3. 两种实现方式

| 方式 | 特点 | 优点 | 缺点 |
|------|------|------|------|
| 记忆化搜索 | 自顶向下，递归 | 思路自然，代码简洁 | 递归栈开销 |
| 动态规划 | 自底向上，迭代 | 无递归开销，可空间优化 | 需要设计计算顺序 |

### 4. 空间优化技巧

- **滚动数组**：当前状态只依赖前一个状态
- **一维数组**：二维 DP 降维
  - 0-1 背包：从后往前遍历
  - 完全背包：从前往后遍历

## 🎯 问题类型总结

### 滑雪问题（路径问题）

**特点**：在图或矩阵中找最优路径

**状态定义**：`dp[i][j]` = 从位置 (i,j) 出发的最优值

**状态转移**：`dp[i][j] = f(dp[相邻位置])`

**适用场景**：
- 最长路径
- 最短路径
- 路径计数

### 背包问题（选择问题）

**特点**：从一组物品中选择，满足约束条件，优化目标函数

**状态定义**：`dp[i][w]` = 前 i 个物品，容量 w 的最优值

**三种类型**：

| 类型 | 限制 | 一维遍历 | 应用场景 |
|------|------|---------|---------|
| 0-1 背包 | 每个选一次 | 从后往前 | 资源分配、任务选择 |
| 完全背包 | 无限次 | 从前往后 | 零钱兑换、物品购买 |
| 多重背包 | 最多 k 次 | 二进制拆分 | 有限资源分配 |

## 🔥 常见 DP 模式

### 模式 1：线性 DP

**特点**：状态按线性顺序排列

**例子**：
- 爬楼梯：`dp[i] = dp[i-1] + dp[i-2]`
- 最长上升子序列：`dp[i] = max(dp[j]) + 1`
- 最长公共子序列：`dp[i][j] = ...`

### 模式 2：区间 DP

**特点**：在一个区间上进行决策

**状态定义**：`dp[i][j]` = 区间 [i, j] 的最优值

**例子**：
- 矩阵链乘法
- 石子合并
- 戳气球

### 模式 3：树形 DP

**特点**：在树结构上进行 DP

**状态定义**：`dp[node][state]` = 以 node 为根的子树的最优值

**例子**：
- 树的最大独立集
- 树的直径
- 打家劫舍 III

### 模式 4：状态压缩 DP

**特点**：用二进制表示状态集合

**状态定义**：`dp[state]` = 状态 state 的最优值

**例子**：
- 旅行商问题（TSP）
- 棋盘覆盖
- 集合划分

## 📚 推荐练习题

### 入门级（理解基础）

1. **LeetCode 70: 爬楼梯**
   - 类型：线性 DP
   - 难度：⭐
   - 状态：`dp[i]` = 到达第 i 阶的方法数

2. **LeetCode 509: 斐波那契数**
   - 类型：线性 DP
   - 难度：⭐
   - 状态：`dp[i]` = 第 i 个斐波那契数

3. **LeetCode 746: 使用最小花费爬楼梯**
   - 类型：线性 DP
   - 难度：⭐
   - 状态：`dp[i]` = 到达第 i 阶的最小花费

### 进阶级（掌握技巧）

4. **LeetCode 300: 最长递增子序列**
   - 类型：线性 DP
   - 难度：⭐⭐
   - 状态：`dp[i]` = 以 nums[i] 结尾的最长递增子序列长度

5. **LeetCode 322: 零钱兑换**
   - 类型：完全背包
   - 难度：⭐⭐
   - 状态：`dp[i]` = 凑成金额 i 的最少硬币数

6. **LeetCode 518: 零钱兑换 II**
   - 类型：完全背包（计数）
   - 难度：⭐⭐
   - 状态：`dp[i]` = 凑成金额 i 的方法数

7. **LeetCode 416: 分割等和子集**
   - 类型：0-1 背包
   - 难度：⭐⭐
   - 状态：`dp[i]` = 是否能凑成和为 i

8. **LeetCode 1143: 最长公共子序列**
   - 类型：二维 DP
   - 难度：⭐⭐
   - 状态：`dp[i][j]` = text1[0..i] 和 text2[0..j] 的 LCS 长度

### 高级（挑战自我）

9. **LeetCode 72: 编辑距离**
   - 类型：二维 DP
   - 难度：⭐⭐⭐
   - 状态：`dp[i][j]` = word1[0..i] 转换为 word2[0..j] 的最少操作数

10. **LeetCode 312: 戳气球**
    - 类型：区间 DP
    - 难度：⭐⭐⭐
    - 状态：`dp[i][j]` = 戳破 (i, j) 区间气球的最大收益

11. **LeetCode 198: 打家劫舍**
    - 类型：线性 DP
    - 难度：⭐⭐
    - 状态：`dp[i]` = 前 i 个房子能偷的最大金额

12. **LeetCode 213: 打家劫舍 II**
    - 类型：线性 DP（环形）
    - 难度：⭐⭐
    - 技巧：拆分成两个线性问题

13. **LeetCode 337: 打家劫舍 III**
    - 类型：树形 DP
    - 难度：⭐⭐⭐
    - 状态：`dp[node][0/1]` = 不偷/偷当前节点的最大金额

14. **LeetCode 139: 单词拆分**
    - 类型：线性 DP
    - 难度：⭐⭐
    - 状态：`dp[i]` = s[0..i] 能否被拆分

15. **LeetCode 279: 完全平方数**
    - 类型：完全背包
    - 难度：⭐⭐
    - 状态：`dp[i]` = 和为 i 的最少完全平方数个数

## 💡 解题技巧

### 技巧 1：从暴力递归开始

```typescript
// 步骤 1：写出暴力递归
function solve(n: number): number {
  if (n <= 1) return 1;
  return solve(n - 1) + solve(n - 2);
}

// 步骤 2：加上记忆化
const memo = new Map<number, number>();
function solveWithMemo(n: number): number {
  if (memo.has(n)) return memo.get(n)!;
  if (n <= 1) return 1;
  const result = solveWithMemo(n - 1) + solveWithMemo(n - 2);
  memo.set(n, result);
  return result;
}

// 步骤 3：改成 DP
function solveDP(n: number): number {
  const dp = new Array(n + 1);
  dp[0] = dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

### 技巧 2：画表格理解

在纸上画出 DP 表格，手动填写几个值，理解状态转移。

### 技巧 3：注意边界条件

仔细处理边界情况，避免数组越界或逻辑错误。

### 技巧 4：验证小规模样例

用小规模的例子验证状态转移方程是否正确。

### 技巧 5：考虑空间优化

在确保正确性后，考虑是否可以优化空间复杂度。

## 🚀 进阶学习资源

### 在线课程
- [动态规划入门到精通](https://www.bilibili.com/video/BV1Xj411K7oF/)
- [MIT 6.006: 动态规划](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)

### 书籍
- 《算法导论》第 15 章：动态规划
- 《算法竞赛进阶指南》
- 《背包九讲》

### 在线资源
- [LeetCode 动态规划专题](https://leetcode.cn/tag/dynamic-programming/)
- [背包九讲 PDF](https://github.com/tianyicui/pack)

## 📊 学习路线图

```
第 1 周：基础入门
├─ 理论学习（本教程）
├─ 简单题练习（爬楼梯、斐波那契）
└─ 理解记忆化搜索

第 2 周：线性 DP
├─ 最长上升子序列
├─ 最长公共子序列
└─ 编辑距离

第 3 周：背包问题
├─ 0-1 背包及变形
├─ 完全背包及变形
└─ 多重背包

第 4 周：进阶主题
├─ 区间 DP
├─ 树形 DP
└─ 状态压缩 DP

持续练习
└─ 每周 3-5 道 DP 题目
```

## ✅ 学习检查清单

- [ ] 理解动态规划的核心思想
- [ ] 能够定义状态和写出状态转移方程
- [ ] 掌握记忆化搜索和 DP 两种方法
- [ ] 理解 0-1 背包和完全背包的区别
- [ ] 能够进行空间优化（二维→一维）
- [ ] 完成至少 20 道 DP 题目
- [ ] 能够独立解决中等难度的 DP 题

## 🎯 最后的建议

1. **多做题**：熟能生巧，DP 需要大量练习
2. **总结模式**：归纳常见的 DP 模式和套路
3. **画图理解**：用表格和图示理解状态转移
4. **从简单开始**：不要一开始就做难题
5. **坚持练习**：每天至少一道 DP 题

## 🌟 结语

动态规划是算法中最重要的思想之一，掌握它将大大提升你的编程能力。

记住三个关键步骤：
1. **定义状态**
2. **找状态转移方程**
3. **确定边界和顺序**

祝你在算法学习的道路上越走越远！💪

---

**有问题？**
- 回顾 `01-理论基础.md`
- 重新学习 `02-滑雪问题.md` 或 `03-背包问题.md`
- 查看代码实现 `skiing.ts` 和 `knapsack.ts`

**继续学习？**
- 开始刷 LeetCode DP 专题
- 学习更高级的 DP 技巧
- 参加算法竞赛

加油！🚀
