# 动态规划理论基础

## 什么是动态规划？

**动态规划（Dynamic Programming，DP）** 是一种通过把原问题分解为子问题的方式来求解复杂问题的方法。

### 核心思想

> **记住已经解决过的子问题的答案，避免重复计算**

简单来说就是：
1. 把大问题拆分成小问题
2. 解决小问题并记录答案
3. 用小问题的答案构建大问题的答案

## 动态规划的两个关键特征

### 1. 最优子结构（Optimal Substructure）

**定义**：一个问题的最优解包含其子问题的最优解。

**例子**：求从 A 到 C 的最短路径
- 如果最短路径是 A → B → C
- 那么 A → B 和 B → C 都必须是最短的

### 2. 重叠子问题（Overlapping Subproblems）

**定义**：在求解过程中，会反复遇到相同的子问题。

**例子**：斐波那契数列
```
fib(5) = fib(4) + fib(3)
       = [fib(3) + fib(2)] + fib(3)
```
可以看到 `fib(3)` 被计算了两次。

## 动态规划的解题步骤

### 步骤 1：定义状态

**状态** 是对问题的一个描述，通常用数组来表示。

**示例**：
- 背包问题：`dp[i][w]` = 前 i 个物品，容量为 w 时的最大价值
- 滑雪问题：`dp[i][j]` = 从位置 (i,j) 出发的最长路径长度

### 步骤 2：找出状态转移方程

状态转移方程描述了状态之间的关系。

**示例**：
- 背包问题：`dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])`
- 滑雪问题：`dp[i][j] = max(dp[nx][ny]) + 1`

### 步骤 3：确定初始状态和边界条件

**示例**：
- 背包问题：`dp[0][w] = 0`（没有物品时价值为 0）
- 滑雪问题：如果周围没有更低的点，`dp[i][j] = 1`

### 步骤 4：确定计算顺序

确保在计算某个状态时，它依赖的状态已经被计算过。

## 两种实现方式

### 方式 1：自顶向下（记忆化搜索）

从目标状态开始，递归计算，用缓存避免重复。

```typescript
const memo: Map<string, number> = new Map();

function dfs(state: State): number {
  // 如果已经计算过，直接返回
  if (memo.has(key)) return memo.get(key)!;
  
  // 边界条件
  if (isBaseCase(state)) return baseValue;
  
  // 递归计算
  const result = /* 根据子问题计算 */;
  memo.set(key, result);
  return result;
}
```

**优点**：
- ✅ 思路自然，容易理解
- ✅ 只计算需要的状态
- ✅ 代码简洁

**缺点**：
- ❌ 递归调用有栈开销
- ❌ 可能栈溢出

### 方式 2：自底向上（动态规划）

从初始状态开始，按顺序计算到目标状态。

```typescript
function dp(n: number): number {
  const dp: number[] = new Array(n + 1);
  
  // 初始化
  dp[0] = baseValue;
  
  // 按顺序计算
  for (let i = 1; i <= n; i++) {
    dp[i] = /* 根据 dp[i-1] 等计算 */;
  }
  
  return dp[n];
}
```

**优点**：
- ✅ 没有递归开销
- ✅ 可以进行空间优化
- ✅ 性能更好

**缺点**：
- ❌ 需要仔细设计计算顺序
- ❌ 可能计算不需要的状态

## 空间优化技巧

### 技巧 1：滚动数组

如果当前状态只依赖前一个状态，可以用两个数组交替使用。

```typescript
let prev: number[] = new Array(m);
let curr: number[] = new Array(m);

for (let i = 0; i < n; i++) {
  for (let j = 0; j < m; j++) {
    curr[j] = /* 根据 prev[j] 计算 */;
  }
  [prev, curr] = [curr, prev]; // 交换
}
```

### 技巧 2：一维数组

如果状态转移只依赖前面的值，可以用一维数组。

```typescript
// 0-1 背包：从后往前更新
for (let i = 0; i < n; i++) {
  for (let w = capacity; w >= weight[i]; w--) {
    dp[w] = Math.max(dp[w], dp[w - weight[i]] + value[i]);
  }
}
```

## 常见 DP 问题分类

### 1. 线性 DP
- 最长上升子序列（LIS）
- 最长公共子序列（LCS）
- 编辑距离

### 2. 区间 DP
- 矩阵链乘法
- 石子合并

### 3. 背包 DP
- 0-1 背包
- 完全背包
- 多重背包

### 4. 树形 DP
- 树的最大独立集
- 树的直径

### 5. 状态压缩 DP
- 旅行商问题（TSP）
- 棋盘覆盖

## 解题技巧

### 1. 画表格
在纸上画出 DP 表格，手动填写几个值，有助于理解状态转移。

### 2. 从暴力递归开始
先写出暴力递归解法，然后加上记忆化，最后改成自底向上的 DP。

### 3. 注意边界条件
仔细处理边界情况，避免数组越界。

### 4. 验证状态转移方程
用小规模的例子验证状态转移方程是否正确。

## 动态规划解题模板

```typescript
// 模板 1：一维 DP
function solve1D(n: number): number {
  // 1. 定义状态数组
  const dp: number[] = new Array(n + 1);
  
  // 2. 初始化边界条件
  dp[0] = /* 初始值 */;
  
  // 3. 状态转移
  for (let i = 1; i <= n; i++) {
    dp[i] = /* 根据 dp[i-1] 等计算 */;
  }
  
  // 4. 返回答案
  return dp[n];
}

// 模板 2：二维 DP
function solve2D(n: number, m: number): number {
  // 1. 定义状态数组
  const dp: number[][] = Array.from({ length: n + 1 }, 
    () => new Array(m + 1).fill(0)
  );
  
  // 2. 初始化边界条件
  for (let i = 0; i <= n; i++) dp[i][0] = /* 初始值 */;
  for (let j = 0; j <= m; j++) dp[0][j] = /* 初始值 */;
  
  // 3. 状态转移
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      dp[i][j] = /* 根据 dp[i-1][j] 等计算 */;
    }
  }
  
  // 4. 返回答案
  return dp[n][m];
}
```

## 下一步

现在你已经了解了动态规划的基础理论，接下来我们通过 **滑雪问题** 来实践这些概念。

👉 继续阅读 `02-滑雪问题.md`
